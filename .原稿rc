
 「Web開発のためのWebGLフレームワーク」というテーマで開発しているGrimoire.jsチームの発表を始めさせていただきたいと思います。

まず、開発チームの自己紹介の方から始めたいと思います。
私が…


さて、以上4名で開発しているのが、このGrimoire.js、Web開発のためのWebGLフレームワークです。
このテーマに含まれているWebGLという言葉、まだまだWeb開発界隈の方でも馴染みの薄い言葉になるかと思います。これを使うと何ができるのでしょうか。

WebGLという言葉を知っている人がもしいたとすれば、その多くがWebGLでできることの第一に3DCGを思い浮かべることと思います。

このように、ブラウザに特別なプラグインなど必要とせず、3DモデルをWeb上で動かすことができます。

こんなエフェクトも、WebGLを用いればできることの一つの例です。3DCGではなくとも、CSSではできない、今までになかった表現をWeb上で可能にします。

他にも、近年ではWeb上でWebカメラやマイクなどを用いれるようになりました。これらと連携すればさらに新しい表現ができます。

最近では、FBなどでは360度画像などがみられるようになりましたが、これも一つのWebGLの応用例です。WebGLの登場によって、様々な表現が今ブラウザ上で誰でも可能になってきているのです。

このようにして見ると、断片的な技術だけですが、実際に既にWebGLを生かしてビジネス展開している企業もあります。
その中でも、Matterportは不動産の内覧をすべてWeb上で完結できるサービスであり、52億円の資金調達を呼ぶまでの大きなマーケットのある技術です。
このような野心的なスタートアップのみならず、皆さんの知っているような企業でも実はWebGLが活用されている例がいくつか散見されるようになりました。

AppleのiPhone7のページでは、テカりの表現にこだわるあまり、 いくつかのiPhoneのテカリはWebGLで描画され、スクロールでテカリ具合が変わるようにまでなっています。

さて、このようにWebGLは近年注目を集めています。しかし、Web上で使えるようになったということと、Web上で使いやすいということは大きく異なります。その実例を一つみてみましょう。

左はただのHTMLで、DIV要素を用いてマウスが乗ったら色が変わり、外れたら色を戻すという操作をJavascriptでやったもの。そして右が、同じようなことを3Dでやったもの。

もし、Webエンジニアの方がいたらそれぞれのコードを思い浮かべてください。どのくらいの行数が必要でしょうか?

実際のコードがこちらです。左側はjQueryを用いて簡単に書いたもの、右側もthree.jsを用いて簡単に書いたものです。
なぜこのようなコードになったのか確認するために少し中を考えてみましょう。

左側はそもそもあらかじめHTMLで固定の部分が書いてあるので、ふるまいを追加するところだけjavascriptでイベントドリブンで記述します。

例えば、ここではマウスがのったら、色を青くし、マウスが出たら色をオレンジにすると記述されています。

一方で右側は、そもそも固定の部分さえもjavascriptで記述しなければならないばかりか、イベントではなく、毎フレーム、マウスの位置から実際の物体と交差しているかを判定して色を変更しています。

このように、いままでHTMLのような固定的な部分を編集する上でイベントドリブンの世界で進化してきたWeb開発からすれば、ループベースで描画内のすべてをjavascriptで記述するWebGLはかなり異色なものです。

ここで、僕らがこのプロジェクトで作成しているGrimoire.jsが登場します。これを用いれば、こんなに短くなります。

そして、このコードは、先ほどのdivのコードにかなり近いように思えるかと思います。

しかし、なぜこんなに短くかけるのか疑問に思えるかもしれません。我々のライブラリでは、先のHTMLのように固定的な部分をまずマークアップで記述します。

例えば、このような記述をして、HTMLから埋め込みたい位置にscriptタグでリンクしてあげればそこがWebGLの管理する空間になります。

色をこのように変えて、大きさをかえるとこんな感じになります。

そして、javascriptで振る舞いを記述していきます。ここに記述すれば、javascriptが動作するようになっています。ここで、先ほどのようにマウスが乗った場合の操作を記述してみましょう。

操作したい対象のマークアップをセレクタで指定して、さらにその中の操作したい要素をセレクタで取得します。あとは、イベントハンドラでmouseenterとmouseleaveで色を変えるなどの処理をするだけです。

これならば、今のようにgrimoireの要素の操作ではなくとも、UIの要素の操作への連携も容易ですし、逆にUIからWebGLへの操作も容易です。さて、ここまでのデモでGrimoire.jsを使えば、いままでのWebのワークフローでWebGLが扱えることがわかったことでしょう。

さて、ここで疑問に思うのがどこまでこの仕組みが実用的な用途に耐えうるのかということでしょう。現実的には表現したいことが我々の用意したタグにはないのかもしれません。

WebGLはいままでのCSSやHTMLだけでできなかった表現を可能にする一方で、その表現全てを網羅するような何かを作成することは現実的に不可能です。
であれば、そのようなユースケースが必要になった際にユーザーがある程度カスタマイズできなければなりません。このような際の拡張性こそ、実はGrimoire.jsの最も優れた点の一つです。

ここでは、一つシンプルな例を出しましょう。ある物体を常に等速で乱回転するようなものを書きたいとします。そのような物体に結びつけることのできる一つの振る舞いをコンポーネントと呼びます。

Grimoire.jsこのような形で物体にくっつけることのできる振る舞いを記述できます。もし、Unityなどのモダンなゲームエンジンに触れたことのある方ならば、これがUnityのようなAPIに似ていることに気がつくでしょう。

これをWebエンジニアがscriptで読み込めば、こう記述するだけで、既存のmeshに回転する機能がつきます。スピードを変えることも容易でしょう。

さらに、この形にしてしまえば、デバッグが今までのWeb開発のように簡単に可能です。Chromeの拡張機能として公開しているインスペクタを使えば、実際に変更されている値を見ることができたりします、。

もう少しわかりやすい例を見せましょう。最初のWebGLを解説する際に出したいくつかの例はGrimoire.jsで作ったものです。最初のモデル表示したサンプルについてみてみましょう。

あのサンプルもたったこれだけのGOMLでできており、このRotateが乱回転をy軸回転のみに修正したものです。
